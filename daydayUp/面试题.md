# 面试题

## 1. 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么

   在组件发生变动时，会根据广度优先算法计算渲染出修改后的组件。当几个兄弟元素改动时，如果有 key 则会减少计算和渲染时间。

   > “建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。”

   key的作用，更新组件时判断两个节点是否相同。相同就复用，不同就删除旧的创建新的。所以用index作为key和不带key的效果相同，index作为key时，每个列表项的index在变更前后都是一样的。

   文档中所说的“刻意依赖默认行为以获取性能上的提升”是指在**渲染简单的无状态组件**时，不带key的效率更高。这时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM文本内容而不是移除/添加节点。

   但不带key会带来一些副作用，列如可能不会产生过渡效果，或者在某些有绑定数据状态的节点会出现状态错位。对于大多数场景来说，列表组件都有自己的状态。建议带上唯一的key，虽然会增加开销但对用户来说基本感受不到差异，而且能保证组件状态正确。

-----

## 2. ['1', '2', '3'].map(parseInt) what & why

  答案 [1, NaN, NaN]

  ```js
  // 等同于 默认传
  ['1','2','3'].map((value, index) => {
    parseInt(value, index)
  })
  // map(callback(value, index, array)) 默认传递三个参数
  // parseInt(string, radix)
  // radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。

  parseInt('1',0)  //1
  parseInt('2',1)  //NaN
  parseInt('3',2)  //NaN

  ```

-----

## 3. 什么是防抖和节流？有什么区别？如何实现

  > 防抖(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

  适用场景：

  1. input事件，按下键盘就会不断触发。如果一次触发就发请求十分浪费资源，实际应用中，需要等到用户输出完整字符后再请求。
  2. 按钮提交场景: 防止多次提交, 只执行最后一次
  3. scroll事件, 在用户停止滚动一段时间后才触发回调
  4. window.resize 调整窗口大小 最后调整结束时触发一次

  实现: 生产环境用 lodash.debounce

  ```js
  const debounce = (fn, delay) => {
    let timer = null
    return (args) => {
      let that = this
      let _args = args
      clearTimeout(timer)
      timer = setTimeout(() => {
        // 注意传递上下文 和 参数
        fn.apply(that, _args)
      }, delay)
    }
  }

  // 使用
  let debounceAjax = debounce(ajax, 500)

  input.addEventListener('keyup', function(e) {
    debounceAjax(e.target.value)
  })

  ```

  > 节流(throttle)：在规定的单位时间内，只能触发一次函数。如果单位时间内多次触发，只有一次生效。

  适用场景:

  1. 监听滚动时间, 例 判断是否滑到底部

实现:

```js
const throttle = (fn, delay) => {
  let flag = true
  return (...args) => {
    if (!flag) return
    flag = false
    setTimeout(() => {
      fn.apply()
      flag = true
    }, delay)
  }
}

const throttle = (fn, delay) => {
  let timer = null
  return (args) => {
    let that = this
    let _args = args
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(that, _args)
        timer = null
      }, delay)
    }
  }
}
```

  总结: 防抖与节流都是防止频繁触发, 但防抖是某段时间内只执行一次, 节流是间隔时间执行.

## 4.JavaScript规定了几种语言类型

7种类型。

1. Undefined
2. Null
3. String
4. Number
5. Boolean
6. Object
7. Symbol (es6新加)

## 5.JavaScript对象的底层数据结构是什么


## 6.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol


## 7.JavaScript中的变量在内存中的具体存储形式


## 8.基本类型对应的内置对象，以及他们之间的装箱拆箱操作


## 9.理解值类型和引用类型


## 10.null和undefined的区别


## 11.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型


## 12.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用


## 13.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法

