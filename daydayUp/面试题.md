# 面试题

## 1. 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么

   在组件发生变动时，会根据广度优先算法计算渲染出修改后的组件。当几个兄弟元素改动时，如果有 key 则会减少计算和渲染时间。

   > “建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。”

   key的作用，更新组件时判断两个节点是否相同。相同就复用，不同就删除旧的创建新的。所以用index作为key和不带key的效果相同，index作为key时，每个列表项的index在变更前后都是一样的。

   文档中所说的“刻意依赖默认行为以获取性能上的提升”是指在**渲染简单的无状态组件**时，不带key的效率更高。这时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM文本内容而不是移除/添加节点。

   但不带key会带来一些副作用，列如可能不会产生过渡效果，或者在某些有绑定数据状态的节点会出现状态错位。对于大多数场景来说，列表组件都有自己的状态。建议带上唯一的key，虽然会增加开销但对用户来说基本感受不到差异，而且能保证组件状态正确。

-----

## 2. ['1', '2', '3'].map(parseInt) what & why

  答案 [1, NaN, NaN]

  ```js
  // 等同于 默认传
  ['1','2','3'].map((value, index) => {
    parseInt(value, index)
  })
  // map(callback(value, index, array)) 默认传递三个参数
  // parseInt(string, radix)
  // radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。

  parseInt('1',0)  //1
  parseInt('2',1)  //NaN
  parseInt('3',2)  //NaN

  ```

-----

## 3. 什么是防抖和节流？有什么区别？如何实现

  > 防抖(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

  例子：input事件，按下键盘就会不断触发。如果一次触发就发请求十分浪费资源，实际应用中，需要等到用户输出完整字符后再请求。

  > 节流(throttle)：在规定的单位时间内，只能触发一次函数。如果单位时间内多次触发，只有一次生效。

4.