# 数据结构与算法之美

## 什么是复杂度分析

1. 数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2. 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4. 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。

## 时间复杂度分析

>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系

低阶，常量，系数并不影响增长趋势，忽略。

### 复杂度分析法则

如果用函数调用另一个函数, 要先集合成一个函数再计算复杂度

1. 单段代码看高频：比如循环。只关注循环执行次数最多的一段代码
2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。总的时间复杂度就等于量级最大的那段代码的时间复杂度
3. 嵌套代码求乘积：比如递归、多重循环等
4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

常见的复杂度量级(按数量级递增)

| 量级              | 复杂度                        | 解释                 |
| ----------------- | ----------------------------- | -------------------- |
| 常量阶            | $O(1)$                        | 常量级, 不存在循环，递归语句. 如果循环的次数是固定的值, 那么也是常量 |
| 对数阶            | $O(logn)$                     |循环次数受内部变量影响
| 线性阶            | $O(n)$                        |循环
| 线性对数阶        | $O(nlogn)$                    |
| 平方/立方/k次方阶 | $O(n^2)$ 、$O(n^3)$、$O(n^k)$ |循环嵌套
| 指数阶            | $O(2^n)$                      | 非多项式阶           |
| 阶乘阶            | $O(n!)$                       | 非多项式阶           |

多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(n^3)

非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)、O(n!)

O(m+n)、O(m*n): 复杂度由2个数据的规模决定, 因为无法判断 n 和 m 哪个大

### 不同情况下的复杂度分析

大多数情况下, 不需要区分下面几种复杂度.

最好情况时间复杂度: 在最理想的情况下, 执行这段代码的时间复杂度
最坏情况时间复杂度: 在最糟糕的情况下, 执行这段代码的时间复杂度
平均情况时间复杂度: 每种情况下要遍历的个数 * 该种情况出现的概率(概率论中的期望值, 加权平均值), 然后忽略系数, 低阶, 常量
均摊时间复杂度: 将耗时多的操作均摊到剩余耗时少的操作上.

## 数组

> Array 是一种线性表数据结构. 它用一组连续的内存空间, 来存储一组具有相同类型的数据

关键词

- 线性表(Linear List): 数据像一条线, 每个线性表上的数据最多只有前后两个方向. 如数组, 链表, 队列, 栈. 
- 非线性表, 如 二叉树, 堆, 图等
- 连续的内存空间和相同类型的数据. 使数组可以随机访问.但也让许多操作变得低效, 比如要在数组中插入或删除一个数据, 为了保证连续性, 就要做大量的数据搬移工作 复杂度O(n)

**为什么数组要从0开始编号, 而不是从1开始 ?**
下标最确切的定义应该是偏移, arr[0]就是偏移为0的位置.arr[k]就表示偏移 k 个 type_size 的位置

## 链表

> 链表通过指针将一组零散的内存块串联在一起.

插入和删除数据很快, 因为本来就是不连续的. 所以不用搬移结点. 复杂度 O(1)
但要访问第 n 个元素就不太高效, 需要根据指针依次遍历 复杂度O(n)

经典应用场景: LRU 缓存淘汰算法

缓存满时, 哪些数据应该被清理, 哪些数据应该被保留 ? 需要缓存淘汰策略来决定

- 先进先出策略 (FIFO First In, First Out)
- 最少使用策略 (LFU Least Frequently Used)
- 最近最少使用策略 (LRU Least Recently Used)

LRU实现思路:

维护一个有序单链表, 越靠近尾部的结点是越早之前访问的, 当有一个新数据被访问时, 从链表头开始顺序遍历链表

1. 如果此数据已经在链表中, 那么将这个数据对应的结点从原来的位置删除, 然后再插入到链表的头部
2. 如果此数据不在缓存链表中
   1. 如果此时缓存未满, 则将此结点直接插入到链表头部
   2. 如果此时缓存已满, 则将尾结点删除, 将新的结点插入到头部

### 单链表

每个链表的节点除了存储数据之外, 还要记录链上下一个结点的地址. 后继指针 next

- 第一个结点: 头结点, 记录链表的基地址. 可以遍历得到整条链表
- 最后一个结点: 尾结点, 指针不是指向下一个结点, 指向一个空地址 NULL

### 循环链表

尾结点指向头结点

### 双向链表

支持两个方向, 虽然多了一些内存占用, 但在某些情况下插入和删除比单链表更节省时间.

用空间换时间

- 删除结点中值等于某个给定值的结点, 单链表和双向链表都要依次遍历比较, 找到对应结点. 遍历查找是主要的耗时点, O(n)
- 删除给定指针指向的结点, 删除某个结点需要知道其上一个结点, 单链表不能直接获取 O(n), 双向链表O(1)

Q: 如何判断一个字符串是否是回文字符串 ?
A: 用快慢指针找到中点, 快指针一次走两格, 慢指针一次走一格, 当快指针走到终点时 慢指针刚好到中点.慢指针前进时顺便修改结点的 next 指针, 使得链表前半部分反序. 比较反序后的字符串与后半部分正常的字符串是否相等

